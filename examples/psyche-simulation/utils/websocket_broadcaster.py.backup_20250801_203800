"""WebSocket Event Broadcaster for NiceGUI integration.

This module provides a WebSocket broadcaster that integrates with NiceGUI
and properly handles client storage access.
"""

import asyncio
import logging
import json
from datetime import datetime
from typing import Dict, Any, Optional, List
from nicegui import ui

from .websocket_events import (
    get_event_manager,
    EventType,
    WebSocketEvent,
    broadcast_agent_message as _broadcast_agent_message,
    broadcast_network_update as _broadcast_network_update,
    broadcast_system_status as _broadcast_system_status,
    broadcast_user_login as _broadcast_user_login,
    broadcast_user_logout as _broadcast_user_logout,
    broadcast_session_update as _broadcast_session_update,
    broadcast_agent_processing_started,
    broadcast_agent_processing_update,
    broadcast_agent_processing_complete
)

logger = logging.getLogger(__name__)


class WebSocketEventBroadcaster:
    """WebSocket event broadcaster with NiceGUI client integration."""
    
    def __init__(self):
        """Initialize the broadcaster."""
        self.event_manager = get_event_manager()
        self._clients = {}  # Track clients by user_id
        
    async def broadcast_agent_message(self, agent_id: str, message: str, 
                                    recipient: Optional[str] = None,
                                    metadata: Optional[Dict[str, Any]] = None):
        """Broadcast agent message to all connected clients.
        
        Args:
            agent_id: ID of the agent sending the message
            message: The message content
            recipient: Optional specific recipient
            metadata: Additional metadata
        """
        try:
            # Use existing broadcast function
            _broadcast_agent_message(
                agent_id=agent_id,
                agent_type=metadata.get('agent_type', 'unknown') if metadata else 'unknown',
                message=message,
                sentiment_data=metadata.get('sentiment') if metadata else None,
                metadata=metadata
            )
            
            # Also broadcast via NiceGUI UI updates
            await self._update_ui_clients('agent_message', {
                'agent_id': agent_id,
                'message': message,
                'recipient': recipient,
                'metadata': metadata
            })
            
        except Exception as e:
            logger.error(f"Error broadcasting agent message: {e}")
    
    async def broadcast_network_update(self, connections: List[Dict[str, Any]], 
                                     metrics: Optional[Dict[str, Any]] = None):
        """Broadcast network update to all connected clients.
        
        Args:
            connections: List of network connections
            metrics: Optional network metrics
        """
        try:
            # Use existing broadcast function
            _broadcast_network_update(
                connections=connections,
                communication_stats=metrics
            )
            
            # Also broadcast via NiceGUI UI updates
            await self._update_ui_clients('network_update', {
                'connections': connections,
                'metrics': metrics
            })
            
        except Exception as e:
            logger.error(f"Error broadcasting network update: {e}")
    
    async def broadcast_system_event(self, event_type: str, data: Dict[str, Any]):
        """Broadcast system event to all connected clients.
        
        Args:
            event_type: Type of system event
            data: Event data
        """
        try:
            # Determine if this is a status update
            if event_type == 'system_status':
                _broadcast_system_status(
                    is_running=data.get('is_running', True),
                    performance_data=data.get('performance_data'),
                    active_agents=data.get('active_agents')
                )
            
            # Broadcast via NiceGUI UI updates
            await self._update_ui_clients(event_type, data)
            
        except Exception as e:
            logger.error(f"Error broadcasting system event: {e}")
    
    async def emit_to_user(self, user_id: str, event_type: str, data: Dict[str, Any]):
        """Emit event to a specific user.
        
        Args:
            user_id: Target user ID
            event_type: Type of event
            data: Event data
        """
        try:
            # Find client for user and send update
            await self._update_specific_user(user_id, event_type, data)
            
        except Exception as e:
            logger.error(f"Error emitting to user {user_id}: {e}")
    
    async def _update_ui_clients(self, event_type: str, data: Dict[str, Any]):
        """Update all connected UI clients.
        
        Args:
            event_type: Type of event
            data: Event data
        """
        try:
            # Use ui.run_javascript to send events to all clients
            js_code = f"""
            if (window.websocketEventHandler) {{
                window.websocketEventHandler({{
                    type: '{event_type}',
                    data: {json.dumps(data)}
                }});
            }}
            """
            
            # Fire and forget - don't await on auto-index page
            # Simply execute without awaiting
            ui.run_javascript(js_code)
            
        except Exception as e:
            logger.error(f"Error updating UI clients: {e}")
    
    async def _update_specific_user(self, user_id: str, event_type: str, data: Dict[str, Any]):
        """Update a specific user's UI.
        
        Args:
            user_id: Target user ID
            event_type: Type of event
            data: Event data
        """
        try:
            # In NiceGUI, we need to use a different approach for user-specific updates
            # We'll use a JavaScript check for the user ID
            js_code = f"""
            if (window.currentUserId === '{user_id}' && window.websocketEventHandler) {{
                window.websocketEventHandler({{
                    type: '{event_type}',
                    data: {json.dumps(data)}
                }});
            }}
            """
            
            # Fire and forget - don't await on auto-index page
            ui.run_javascript(js_code)
            
        except Exception as e:
            logger.error(f"Error updating specific user {user_id}: {e}")
    
    async def _broadcast_to_users(self, event_type: str, data: Dict[str, Any], user_ids: Optional[List[str]] = None):
        """Broadcast event to specific users or all users.
        
        This method is provided for compatibility but uses the UI update methods internally.
        
        Args:
            event_type: Type of event
            data: Event data
            user_ids: Optional list of user IDs to target
        """
        try:
            if user_ids is None:
                # Broadcast to all
                await self._update_ui_clients(event_type, data)
            else:
                # Broadcast to specific users
                for user_id in user_ids:
                    await self._update_specific_user(user_id, event_type, data)
                    
        except Exception as e:
            logger.error(f"Error in broadcast: {e}")
    
    async def _send_to_client(self, client: Any, event_type: str, data: Dict[str, Any]):
        """Send event to a specific client.
        
        This method is provided for compatibility.
        
        Args:
            client: Client object (not used in this implementation)
            event_type: Type of event
            data: Event data
        """
        # In this implementation, we use JavaScript-based updates
        await self._update_ui_clients(event_type, data)


class RealtimeUIUpdater:
    """Manages real-time UI updates based on WebSocket events."""
    
    def __init__(self, broadcaster: Optional['WebSocketBroadcaster'] = None):
        """Initialize the UI updater.
        
        Args:
            broadcaster: Optional WebSocket broadcaster instance
        """
        self.broadcaster = broadcaster
        self.ui_elements = {}
        self.event_handlers = {
            'agent_message': self.handle_agent_message,
            'agent_processing_started': self.handle_agent_processing_started,  # NEW
            'agent_processing_update': self.handle_agent_processing_update,    # NEW
            'agent_processing_complete': self.handle_agent_processing_complete, # NEW
            'network_update': self.handle_network_update,
            'system_status': self.handle_system_status,
            'health_update': self.handle_health_update,
            'emergency_status': self.handle_emergency_status
        }
        self._active_animations = {}
        self._message_counter = 0
        
    def register_element(self, element_id: str, element: Any):
        """Register a UI element for updates.
        
        Args:
            element_id: Unique identifier for the element
            element: The NiceGUI element to update
        """
        self.ui_elements[element_id] = element
        logger.debug(f"Registered UI element: {element_id}")
        
    async def handle_agent_message(self, event: WebSocketEvent):
        """Handle agent message events with visual updates."""
        data = event.data
        self._message_counter += 1
        
        # Update conversation display with animation
        if 'conversation_display' in self.ui_elements:
            conv_display = self.ui_elements['conversation_display']
            
            # Create animated message card
            with conv_display:
                # Add message with fade-in animation
                with ui.card().classes('w-full mb-4 agent-message-card opacity-0 transition-opacity duration-500') as card:
                    # Agent header with status indicator
                    with ui.row().classes('items-center justify-between mb-2'):
                        with ui.row().classes('items-center gap-2'):
                            # Animated status dot
                            ui.icon('circle').classes(f'text-xs animate-pulse text-{self._get_agent_color(data["agent_id"])}')
                            ui.label(data['agent_id']).classes('font-bold')
                        
                        # Timestamp
                        timestamp = datetime.now().strftime('%H:%M:%S')
                        ui.label(timestamp).classes('text-xs text-gray-500')
                    
                    # Message content with typing animation
                    message_label = ui.label(data['content']).classes('message-content')
                    
                    # Sentiment indicator if available
                    if 'sentiment' in data:
                        sentiment = data['sentiment']
                        color = self._get_sentiment_color(sentiment.get('score', 0))
                        with ui.row().classes('items-center gap-2 mt-2'):
                            ui.icon('mood').classes(f'text-sm text-{color}')
                            ui.label(f"{sentiment.get('label', 'neutral')} ({sentiment.get('score', 0):.2f})").classes('text-sm text-gray-400')
                
                # Animate the card appearance
                asyncio.create_task(ui.run_javascript(f"""
                    setTimeout(() => {{
                        const card = document.querySelector('.agent-message-card:last-child');
                        if (card) {{
                            card.classList.remove('opacity-0');
                            card.classList.add('opacity-100');
                        }}
                    }}, 100);
                """))
                
                # Auto-scroll to bottom
                asyncio.create_task(ui.run_javascript("""
                    const container = document.querySelector('.conversation-container');
                    if (container) {
                        container.scrollTop = container.scrollHeight;
                    }
                """))
        
        # Update message counter
        if 'message_counter' in self.ui_elements:
            self.ui_elements['message_counter'].set_text(f'Messages: {self._message_counter}')
            
        # Flash notification
        if 'notification_area' in self.ui_elements:
            await self._flash_notification(f"New message from {data['agent_id']}")
    
    async def handle_network_update(self, event: WebSocketEvent):
        """Handle network updates with visual changes."""
        data = event.data
        
        # Update network visualization
        if 'network_chart' in self.ui_elements:
            # This will be handled by the existing plotly update
            pass
            
        # Update network metrics with animation
        if 'network_metrics' in self.ui_elements:
            connections = len(data.get('connections', []))
            health = data.get('metrics', {}).get('health', 1.0)
            
            metrics_text = f'Connections: {connections} | Health: {health:.2f}'
            self.ui_elements['network_metrics'].set_text(metrics_text)
            
            # Pulse animation for network activity
            asyncio.create_task(ui.run_javascript("""
                const metrics = document.querySelector('.network-metrics');
                if (metrics) {
                    metrics.classList.add('animate-pulse');
                    setTimeout(() => metrics.classList.remove('animate-pulse'), 1000);
                }
            """))
    
    async def handle_system_status(self, event: WebSocketEvent):
        """Handle system status updates with visual indicators."""
        data = event.data
        
        # Update status indicator with color change
        if 'status_indicator' in self.ui_elements:
            is_running = data.get('is_running', False)
            status = 'RUNNING' if is_running else 'STOPPED'
            color = 'green' if is_running else 'red'
            
            self.ui_elements['status_indicator'].set_text(f'System: {status}')
            self.ui_elements['status_indicator'].classes(f'text-{color}-400', 
                remove='text-green-400 text-red-400 text-yellow-400')
            
            # Add spinning animation when running
            if is_running:
                asyncio.create_task(ui.run_javascript("""
                    const indicator = document.querySelector('.status-indicator');
                    if (indicator) {
                        indicator.innerHTML = '<i class="material-icons animate-spin">refresh</i> System: RUNNING';
                    }
                """))
        
        # Update resource display
        if 'resource_display' in self.ui_elements and 'performance_data' in data:
            perf = data['performance_data']
            cpu = perf.get('cpu_percent', 0)
            memory = perf.get('memory_percent', 0)
            threads = perf.get('thread_count', 0)
            
            self.ui_elements['resource_display'].set_text(
                f'CPU: {cpu:.1f}% | Memory: {memory:.1f}% | Threads: {threads}'
            )
    
    async def handle_health_update(self, event: WebSocketEvent):
        """Handle health metric updates with visual indicators."""
        data = event.data
        
        # Update health indicators with color coding
        for metric, value in data.items():
            if metric in self.ui_elements:
                element = self.ui_elements[metric]
                
                # Update progress bar
                if hasattr(element, 'set_value'):
                    element.set_value(value)
                    
                # Color coding based on thresholds
                color = self._get_health_color(metric, value)
                element.classes(f'bg-{color}-500', remove='bg-red-500 bg-yellow-500 bg-green-500')
                
                # Add warning animation for critical values
                if color == 'red':
                    asyncio.create_task(ui.run_javascript(f"""
                        const element = document.querySelector('[data-metric="{metric}"]');
                        if (element) {{
                            element.classList.add('animate-pulse');
                        }}
                    """))
    
    async def handle_emergency_status(self, event: WebSocketEvent):
        """Handle emergency status updates with alerts."""
        data = event.data
        
        if 'emergency_status' in self.ui_elements:
            is_emergency = data.get('emergency_mode', False)
            
            if is_emergency:
                # Show emergency alert with animation
                self.ui_elements['emergency_status'].set_text('ðŸš¨ EMERGENCY MODE ACTIVE')
                self.ui_elements['emergency_status'].classes('text-red-500 animate-pulse font-bold')
                
                # Show notification
                ui.notify('Emergency communication mode activated!', type='negative', position='top')
                
                # Add flashing border to conversation area
                asyncio.create_task(ui.run_javascript("""
                    const convArea = document.querySelector('.conversation-container');
                    if (convArea) {
                        convArea.style.border = '2px solid red';
                        convArea.classList.add('animate-pulse');
                    }
                """))
            else:
                self.ui_elements['emergency_status'].set_text('âœ… Normal Operation')
                self.ui_elements['emergency_status'].classes('text-green-400',
                    remove='text-red-500 animate-pulse font-bold')
    
    async def handle_agent_processing_started(self, event: WebSocketEvent):
        """Handle agent processing started events."""
        data = event.data
        
        # Show loading indicator
        if 'conversation_display' in self.ui_elements:
            conv_display = self.ui_elements['conversation_display']
            
            with conv_display:
                # Add processing indicator card
                with ui.card().classes('w-full mb-4 agent-processing-card bg-blue-50') as card:
                    card.set_id(f"processing-{data['agent_id']}")
                    
                    with ui.row().classes('items-center gap-2'):
                        # Animated spinner
                        ui.icon('refresh').classes('animate-spin text-blue-500')
                        ui.label(f"{data['agent_id']} is thinking...").classes('font-semibold')
                    
                    # Container for streaming text
                    ui.markdown('').classes('streaming-content text-sm mt-2').set_id(
                        f"streaming-{data['agent_id']}"
                    )
        
        # Update status
        if 'agent_status' in self.ui_elements:
            self.ui_elements['agent_status'].set_text(f"{data['agent_id']}: Processing...")
    
    async def handle_agent_processing_update(self, event: WebSocketEvent):
        """Handle streaming updates during agent processing."""
        data = event.data
        
        # Update streaming content
        asyncio.create_task(ui.run_javascript(f"""
            const streamingEl = document.getElementById('streaming-{data["agent_id"]}');
            if (streamingEl) {{
                streamingEl.textContent += '{data["partial_content"]}';
                
                // Auto-scroll
                const container = document.querySelector('.conversation-container');
                if (container) {{
                    container.scrollTop = container.scrollHeight;
                }}
            }}
            
            // Update progress if available
            const progress = {data.get("progress", 0)} * 100;
            const card = document.getElementById('processing-{data["agent_id"]}');
            if (card && progress > 0) {{
                card.style.background = `linear-gradient(to right, #dbeafe ${progress}%, #eff6ff ${progress}%)`;
            }}
        """))
    
    async def handle_agent_processing_complete(self, event: WebSocketEvent):
        """Handle agent processing complete events."""
        data = event.data
        
        # Remove processing card and add final message
        if 'conversation_display' in self.ui_elements:
            # Remove processing indicator
            asyncio.create_task(ui.run_javascript(f"""
                const processingCard = document.getElementById('processing-{data["agent_id"]}');
                if (processingCard) {{
                    processingCard.remove();
                }}
            """))
            
            # Add final message using existing handler
            # Convert to agent_message format
            message_event = WebSocketEvent(
                type=EventType.AGENT_MESSAGE,
                data={
                    'agent_id': data['agent_id'],
                    'content': data['final_content'],
                    'sentiment': data.get('sentiment', {'score': 0.0, 'label': 'neutral'}),
                    'metadata': data.get('metadata', {})
                }
            )
            await self.handle_agent_message(message_event)
    
    async def _flash_notification(self, message: str):
        """Show a temporary notification flash."""
        if 'notification_area' in self.ui_elements:
            area = self.ui_elements['notification_area']
            
            # Create notification
            with area:
                with ui.card().classes('notification-flash opacity-0 transition-opacity duration-300 bg-blue-600 text-white p-2 rounded') as notif:
                    ui.label(message).classes('text-sm')
            
            # Animate in
            asyncio.create_task(ui.run_javascript("""
                const notif = document.querySelector('.notification-flash:last-child');
                if (notif) {
                    setTimeout(() => notif.classList.add('opacity-100'), 100);
                    setTimeout(() => {
                        notif.classList.remove('opacity-100');
                        setTimeout(() => notif.remove(), 300);
                    }, 3000);
                }
            """))
    
    def _get_agent_color(self, agent_id: str) -> str:
        """Get color for agent based on ID."""
        colors = {
            'Shadow': 'gray-600',
            'Persona': 'blue-600',
            'Anima/Animus': 'purple-600',
            'Self': 'orange-600',
            'Ego': 'green-600'
        }
        return colors.get(agent_id, 'gray-400')
    
    def _get_sentiment_color(self, score: float) -> str:
        """Get color based on sentiment score."""
        if score > 0.6:
            return 'green'
        elif score > 0.3:
            return 'yellow'
        else:
            return 'red'
    
    def _get_health_color(self, metric: str, value: float) -> str:
        """Get color for health metric based on value."""
        if metric in ['stagnation', 'repetition']:
            if value > 0.7:
                return 'red'
            elif value > 0.4:
                return 'yellow'
            else:
                return 'green'
        elif metric in ['engagement', 'diversity']:
            if value < 0.3:
                return 'red'
            elif value < 0.6:
                return 'yellow'
            else:
                return 'green'
        else:
            if value > 0.8 or value < 0.2:
                return 'red'
            elif value > 0.6 or value < 0.4:
                return 'yellow'
            else:
                return 'green'


# Alias for compatibility
WebSocketBroadcaster = WebSocketEventBroadcaster


# Global broadcaster instance
_broadcaster: Optional[WebSocketEventBroadcaster] = None


def get_broadcaster() -> WebSocketEventBroadcaster:
    """Get or create the global broadcaster instance.
    
    Returns:
        The global WebSocketEventBroadcaster instance
    """
    global _broadcaster
    
    if _broadcaster is None:
        _broadcaster = WebSocketEventBroadcaster()
    
    return _broadcaster