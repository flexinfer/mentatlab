# PKI Infrastructure Implementation Guide
## MentatLab v1.0 Attestation System

*Version: 1.0*  
*Date: August 1, 2025*

---

## Table of Contents
1. [Overview](#overview)
2. [Prerequisites](#prerequisites)
3. [PKI Architecture](#pki-architecture)
4. [Implementation Steps](#implementation-steps)
5. [Certificate Management](#certificate-management)
6. [Integration with CI/CD](#integration-with-cicd)
7. [Security Operations](#security-operations)
8. [Troubleshooting](#troubleshooting)

---

## Overview

This guide provides comprehensive instructions for implementing the PKI (Public Key Infrastructure) system that enables cryptographic signing and verification of agent manifests in MentatLab v1.0.

### Goals
- Establish a certificate hierarchy for agent signing
- Implement manifest signing and verification
- Enable certificate lifecycle management
- Integrate with development workflows

---

## Prerequisites

### Software Requirements
```bash
# Install OpenSSL
sudo apt-get update
sudo apt-get install openssl

# Install HashiCorp Vault (for certificate management)
curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add -
sudo apt-add-repository "deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs) main"
sudo apt-get update && sudo apt-get install vault

# Install Python dependencies
pip install cryptography pyyaml python-dateutil

# Install Go for PKI service
wget https://go.dev/dl/go1.21.0.linux-amd64.tar.gz
sudo tar -C /usr/local -xzf go1.21.0.linux-amd64.tar.gz
```

### Infrastructure Requirements
- HashiCorp Vault cluster (or similar PKI backend)
- PostgreSQL database for certificate tracking
- Redis for revocation caching
- S3-compatible storage for certificate backups

---

## PKI Architecture

### Certificate Hierarchy

```
┌─────────────────────────┐
│   Root CA (10 years)    │
│  CN=MentatLab Root CA   │
└────────────┬────────────┘
             │
┌────────────▼────────────┐
│ Intermediate CA (5 yrs) │
│ CN=MentatLab Agent CA   │
└────────────┬────────────┘
             │
┌────────────▼────────────┐
│ Developer Cert (1 year) │
│ CN=developer@company.com│
└──────────────────────────┘
```

### Component Architecture

```
services/pki-service/
├── cmd/
│   └── pki-server/
│       └── main.go
├── internal/
│   ├── ca/
│   │   ├── root.go
│   │   ├── intermediate.go
│   │   └── issuer.go
│   ├── store/
│   │   ├── vault.go
│   │   ├── postgres.go
│   │   └── cache.go
│   ├── api/
│   │   ├── grpc.go
│   │   ├── rest.go
│   │   └── handlers.go
│   └── verify/
│       ├── chain.go
│       ├── revocation.go
│       └── policy.go
├── pkg/
│   ├── cert/
│   │   └── types.go
│   └── sign/
│       └── manifest.go
└── configs/
    └── pki-config.yaml
```

---

## Implementation Steps

### Step 1: Set Up Root Certificate Authority

```go
// internal/ca/root.go
package ca

import (
    "crypto/rand"
    "crypto/rsa"
    "crypto/x509"
    "crypto/x509/pkix"
    "encoding/pem"
    "math/big"
    "time"
)

type RootCA struct {
    Certificate *x509.Certificate
    PrivateKey  *rsa.PrivateKey
}

func GenerateRootCA() (*RootCA, error) {
    // Generate RSA key pair
    privateKey, err := rsa.GenerateKey(rand.Reader, 4096)
    if err != nil {
        return nil, err
    }
    
    // Create certificate template
    template := &x509.Certificate{
        SerialNumber: big.NewInt(1),
        Subject: pkix.Name{
            Organization:  []string{"MentatLab"},
            Country:       []string{"US"},
            Province:      []string{""},
            Locality:      []string{""},
            StreetAddress: []string{""},
            PostalCode:    []string{""},
            CommonName:    "MentatLab Root CA",
        },
        NotBefore:             time.Now(),
        NotAfter:              time.Now().Add(10 * 365 * 24 * time.Hour), // 10 years
        IsCA:                  true,
        KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
        ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
        BasicConstraintsValid: true,
        MaxPathLen:            2,
    }
    
    // Self-sign the certificate
    certBytes, err := x509.CreateCertificate(
        rand.Reader,
        template,
        template,
        &privateKey.PublicKey,
        privateKey,
    )
    if err != nil {
        return nil, err
    }
    
    // Parse the certificate
    cert, err := x509.ParseCertificate(certBytes)
    if err != nil {
        return nil, err
    }
    
    return &RootCA{
        Certificate: cert,
        PrivateKey:  privateKey,
    }, nil
}

func (ca *RootCA) SaveToVault(client *vault.Client) error {
    // Convert to PEM format
    certPEM := pem.EncodeToMemory(&pem.Block{
        Type:  "CERTIFICATE",
        Bytes: ca.Certificate.Raw,
    })
    
    keyPEM := pem.EncodeToMemory(&pem.Block{
        Type:  "RSA PRIVATE KEY",
        Bytes: x509.MarshalPKCS1PrivateKey(ca.PrivateKey),
    })
    
    // Store in Vault
    _, err := client.Logical().Write("pki/root/generate/internal", map[string]interface{}{
        "common_name": "MentatLab Root CA",
        "ttl":         "87600h", // 10 years
        "key_type":    "rsa",
        "key_bits":    4096,
    })
    
    return err
}
```

### Step 2: Create Intermediate CA

```go
// internal/ca/intermediate.go
package ca

type IntermediateCA struct {
    Certificate *x509.Certificate
    PrivateKey  *rsa.PrivateKey
    RootCA      *RootCA
}

func GenerateIntermediateCA(rootCA *RootCA) (*IntermediateCA, error) {
    // Generate key pair
    privateKey, err := rsa.GenerateKey(rand.Reader, 3072)
    if err != nil {
        return nil, err
    }
    
    // Create certificate template
    template := &x509.Certificate{
        SerialNumber: big.NewInt(2),
        Subject: pkix.Name{
            Organization: []string{"MentatLab"},
            Country:      []string{"US"},
            CommonName:   "MentatLab Agent CA",
        },
        NotBefore:             time.Now(),
        NotAfter:              time.Now().Add(5 * 365 * 24 * time.Hour), // 5 years
        IsCA:                  true,
        KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign | x509.KeyUsageCRLSign,
        ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageCodeSigning},
        BasicConstraintsValid: true,
        MaxPathLen:            0,
        MaxPathLenZero:        true,
    }
    
    // Sign with root CA
    certBytes, err := x509.CreateCertificate(
        rand.Reader,
        template,
        rootCA.Certificate,
        &privateKey.PublicKey,
        rootCA.PrivateKey,
    )
    if err != nil {
        return nil, err
    }
    
    cert, err := x509.ParseCertificate(certBytes)
    if err != nil {
        return nil, err
    }
    
    return &IntermediateCA{
        Certificate: cert,
        PrivateKey:  privateKey,
        RootCA:      rootCA,
    }, nil
}

func (ca *IntermediateCA) SetupVaultMount(client *vault.Client) error {
    // Enable PKI secrets engine for intermediate CA
    err := client.Sys().Mount("pki_int", &vault.MountInput{
        Type: "pki",
        Config: vault.MountConfigInput{
            MaxLeaseTTL: "43800h", // 5 years
        },
    })
    if err != nil {
        return err
    }
    
    // Generate intermediate CSR
    csr, err := client.Logical().Write("pki_int/intermediate/generate/internal", map[string]interface{}{
        "common_name": "MentatLab Agent CA",
        "key_type":    "rsa",
        "key_bits":    3072,
    })
    if err != nil {
        return err
    }
    
    // Sign CSR with root CA
    signedCert, err := client.Logical().Write("pki/root/sign-intermediate", map[string]interface{}{
        "csr":    csr.Data["csr"],
        "format": "pem_bundle",
        "ttl":    "43800h",
    })
    if err != nil {
        return err
    }
    
    // Set signed certificate
    _, err = client.Logical().Write("pki_int/intermediate/set-signed", map[string]interface{}{
        "certificate": signedCert.Data["certificate"],
    })
    
    return err
}
```

### Step 3: Implement Certificate Issuer

```go
// internal/ca/issuer.go
package ca

import (
    "fmt"
    "net/mail"
    "time"
)

type CertificateIssuer struct {
    IntermediateCA *IntermediateCA
    Store          CertificateStore
    Policy         *IssuancePolicy
}

type DeveloperCertRequest struct {
    Email       string
    PublicKey   *rsa.PublicKey
    ValidityDays int
}

type IssuancePolicy struct {
    MaxValidityDays    int
    AllowedDomains     []string
    RequireEmailVerify bool
}

func (issuer *CertificateIssuer) IssueDeveloperCert(req *DeveloperCertRequest) (*x509.Certificate, error) {
    // Validate request
    if err := issuer.validateRequest(req); err != nil {
        return nil, err
    }
    
    // Generate serial number
    serialNumber, err := generateSerialNumber()
    if err != nil {
        return nil, err
    }
    
    // Create certificate template
    template := &x509.Certificate{
        SerialNumber: serialNumber,
        Subject: pkix.Name{
            Organization: []string{"MentatLab"},
            Country:      []string{"US"},
            CommonName:   req.Email,
        },
        EmailAddresses:        []string{req.Email},
        NotBefore:            time.Now(),
        NotAfter:             time.Now().Add(time.Duration(req.ValidityDays) * 24 * time.Hour),
        KeyUsage:             x509.KeyUsageDigitalSignature,
        ExtKeyUsage:          []x509.ExtKeyUsage{x509.ExtKeyUsageCodeSigning},
        BasicConstraintsValid: true,
        IsCA:                 false,
        
        // Custom extensions
        ExtraExtensions: []pkix.Extension{
            {
                Id:    asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 99999, 1}, // Custom OID
                Value: []byte("agent-signing"),
            },
        },
    }
    
    // Add Subject Alternative Names
    template.DNSNames = []string{}
    template.IPAddresses = []net.IP{}
    
    // Sign certificate
    certBytes, err := x509.CreateCertificate(
        rand.Reader,
        template,
        issuer.IntermediateCA.Certificate,
        req.PublicKey,
        issuer.IntermediateCA.PrivateKey,
    )
    if err != nil {
        return nil, err
    }
    
    cert, err := x509.ParseCertificate(certBytes)
    if err != nil {
        return nil, err
    }
    
    // Store certificate
    if err := issuer.Store.SaveCertificate(cert); err != nil {
        return nil, err
    }
    
    // Log issuance
    log.Info("Certificate issued",
        "serial", cert.SerialNumber.String(),
        "subject", cert.Subject.String(),
        "validity_days", req.ValidityDays,
    )
    
    return cert, nil
}

func (issuer *CertificateIssuer) validateRequest(req *DeveloperCertRequest) error {
    // Validate email
    _, err := mail.ParseAddress(req.Email)
    if err != nil {
        return fmt.Errorf("invalid email address: %w", err)
    }
    
    // Check domain allowlist
    if len(issuer.Policy.AllowedDomains) > 0 {
        allowed := false
        for _, domain := range issuer.Policy.AllowedDomains {
            if strings.HasSuffix(req.Email, "@"+domain) {
                allowed = true
                break
            }
        }
        if !allowed {
            return fmt.Errorf("email domain not allowed")
        }
    }
    
    // Validate validity period
    if req.ValidityDays > issuer.Policy.MaxValidityDays {
        return fmt.Errorf("validity period exceeds maximum of %d days", issuer.Policy.MaxValidityDays)
    }
    
    return nil
}
```

### Step 4: Implement Manifest Signing

```go
// pkg/sign/manifest.go
package sign

import (
    "crypto"
    "crypto/rand"
    "crypto/rsa"
    "crypto/sha256"
    "crypto/x509"
    "encoding/base64"
    "encoding/json"
    "time"
    
    "gopkg.in/yaml.v3"
)

type ManifestSigner struct {
    Certificate *x509.Certificate
    PrivateKey  *rsa.PrivateKey
}

type SignedManifest struct {
    Manifest    map[string]interface{} `yaml:",inline"`
    Attestation Attestation           `yaml:"attestation"`
}

type Attestation struct {
    Version         string   `yaml:"version"`
    Timestamp       string   `yaml:"timestamp"`
    Signer          Signer   `yaml:"signer"`
    Algorithm       string   `yaml:"algorithm"`
    Signature       string   `yaml:"signature"`
    CertificateChain []string `yaml:"certificate_chain"`
}

type Signer struct {
    Subject string `yaml:"subject"`
    Issuer  string `yaml:"issuer"`
}

func (s *ManifestSigner) SignManifest(manifestPath string) (*SignedManifest, error) {
    // Read manifest
    data, err := os.ReadFile(manifestPath)
    if err != nil {
        return nil, err
    }
    
    var manifest map[string]interface{}
    if err := yaml.Unmarshal(data, &manifest); err != nil {
        return nil, err
    }
    
    // Remove existing attestation if present
    delete(manifest, "attestation")
    
    // Canonicalize manifest
    canonical, err := s.canonicalizeManifest(manifest)
    if err != nil {
        return nil, err
    }
    
    // Calculate hash
    hash := sha256.Sum256(canonical)
    
    // Sign hash
    signature, err := rsa.SignPKCS1v15(rand.Reader, s.PrivateKey, crypto.SHA256, hash[:])
    if err != nil {
        return nil, err
    }
    
    // Build certificate chain
    chain := s.buildCertificateChain()
    
    // Create attestation
    attestation := Attestation{
        Version:   "1.0",
        Timestamp: time.Now().UTC().Format(time.RFC3339),
        Signer: Signer{
            Subject: s.Certificate.Subject.String(),
            Issuer:  s.Certificate.Issuer.String(),
        },
        Algorithm:        "SHA256withRSA",
        Signature:        base64.StdEncoding.EncodeToString(signature),
        CertificateChain: chain,
    }
    
    return &SignedManifest{
        Manifest:    manifest,
        Attestation: attestation,
    }, nil
}

func (s *ManifestSigner) canonicalizeManifest(manifest map[string]interface{}) ([]byte, error) {
    // Sort keys for deterministic output
    sorted := make(map[string]interface{})
    keys := make([]string, 0, len(manifest))
    
    for k := range manifest {
        keys = append(keys, k)
    }
    sort.Strings(keys)
    
    for _, k := range keys {
        sorted[k] = manifest[k]
    }
    
    // Convert to canonical JSON
    return json.Marshal(sorted)
}

func (s *ManifestSigner) buildCertificateChain() []string {
    chain := []string{}
    
    // Add developer certificate
    chain = append(chain, base64.StdEncoding.EncodeToString(s.Certificate.Raw))
    
    // Add intermediate CA
    if len(s.Certificate.Issuer.String()) > 0 {
        // In production, fetch from certificate store
        intermediateCA := s.fetchIntermediateCA()
        if intermediateCA != nil {
            chain = append(chain, base64.StdEncoding.EncodeToString(intermediateCA.Raw))
        }
    }
    
    return chain
}
```

### Step 5: Implement Verification Service

```go
// internal/verify/chain.go
package verify

import (
    "crypto/x509"
    "encoding/base64"
    "fmt"
    "time"
)

type ManifestVerifier struct {
    TrustStore       *x509.CertPool
    RevocationClient *RevocationClient
    PolicyEngine     *PolicyEngine
}

func NewManifestVerifier(rootCAPath string) (*ManifestVerifier, error) {
    // Load root CA
    rootCAData, err := os.ReadFile(rootCAPath)
    if err != nil {
        return nil, err
    }
    
    trustStore := x509.NewCertPool()
    if !trustStore.AppendCertsFromPEM(rootCAData) {
        return nil, fmt.Errorf("failed to load root CA")
    }
    
    return &ManifestVerifier{
        TrustStore:       trustStore,
        RevocationClient: NewRevocationClient(),
        PolicyEngine:     NewPolicyEngine(),
    }, nil
}

func (v *ManifestVerifier) VerifyManifest(signedManifest *SignedManifest) (*VerificationResult, error) {
    result := &VerificationResult{
        Valid:     false,
        Timestamp: time.Now(),
    }
    
    // 1. Parse certificate chain
    chain, err := v.parseCertificateChain(signedManifest.Attestation.CertificateChain)
    if err != nil {
        result.Error = fmt.Sprintf("invalid certificate chain: %v", err)
        return result, nil
    }
    
    // 2. Verify certificate chain
    if err := v.verifyCertificateChain(chain); err != nil {
        result.Error = fmt.Sprintf("certificate chain verification failed: %v", err)
        return result, nil
    }
    
    // 3. Check revocation status
    for _, cert := range chain {
        revoked, err := v.RevocationClient.IsRevoked(cert)
        if err != nil {
            result.Error = fmt.Sprintf("revocation check failed: %v", err)
            return result, nil
        }
        if revoked {
            result.Error = fmt.Sprintf("certificate %s is revoked", cert.SerialNumber)
            return result, nil
        }
    }
    
    // 4. Verify signature
    if err := v.verifySignature(signedManifest, chain[0]); err != nil {
        result.Error = fmt.Sprintf("signature verification failed: %v", err)
        return result, nil
    }
    
    // 5. Apply policy checks
    policyResult := v.PolicyEngine.Evaluate(chain[0], signedManifest)
    if !policyResult.Allowed {
        result.Error = fmt.Sprintf("policy check failed: %s", policyResult.Reason)
        return result, nil
    }
    
    result.Valid = true
    result.Signer = chain[0].Subject.String()
    result.SignerEmail = v.extractEmail(chain[0])
    result.TrustLevel = v.calculateTrustLevel(chain[0])
    
    return result, nil
}

func (v *ManifestVerifier) verifyCertificateChain(chain []*x509.Certificate) error {
    if len(chain) == 0 {
        return fmt.Errorf("empty certificate chain")
    }
    
    // Create verification options
    opts := x509.VerifyOptions{
        Roots:         v.TrustStore,
        Intermediates: x509.NewCertPool(),
        CurrentTime:   time.Now(),
        KeyUsages:     []x509.ExtKeyUsage{x509.ExtKeyUsageCodeSigning},
    }
    
    // Add intermediates
    for i := 1; i < len(chain); i++ {
        opts.Intermediates.AddCert(chain[i])
    }
    
    // Verify chain
    chains, err := chain[0].Verify(opts)
    if err != nil {
        return err
    }
    
    if len(chains) == 0 {
        return fmt.Errorf("no valid certificate chains found")
    }
    
    return nil
}

func (v *ManifestVerifier) verifySignature(manifest *SignedManifest, cert *x509.Certificate) error {
    // Recreate canonical form
    canonical, err := canonicalizeManifest(manifest.Manifest)
    if err != nil {
        return err
    }
    
    // Decode signature
    signature, err := base64.StdEncoding.DecodeString(manifest.Attestation.Signature)
    if err != nil {
        return err
    }
    
    // Calculate hash
    hash := sha256.Sum256(canonical)
    
    // Verify signature
    return rsa.VerifyPKCS1v15(cert.PublicKey.(*rsa.PublicKey), crypto.SHA256, hash[:], signature)
}
```

### Step 6: Implement Revocation Service

```go
// internal/verify/revocation.go
package verify

import (
    "context"
    "crypto/x509"
    "encoding/hex"
    "time"
    
    "github.com/go-redis/redis/v8"
)

type RevocationClient struct {
    redis    *redis.Client
    postgres *sql.DB
    ocspURL  string
}

type RevocationEntry struct {
    SerialNumber string    `db:"serial_number"`
    RevokedAt    time.Time `db:"revoked_at"`
    Reason       string    `db:"reason"`
}

func (r *RevocationClient) IsRevoked(cert *x509.Certificate) (bool, error) {
    ctx := context.Background()
    serialHex := hex.EncodeToString(cert.SerialNumber.Bytes())
    
    // Check Redis cache first
    cached, err := r.redis.Get(ctx, fmt.Sprintf("revoked:%s", serialHex)).Result()
    if err == nil {
        return cached == "true", nil
    }
    
    // Check database
    var entry RevocationEntry
    err = r.postgres.QueryRowContext(ctx,
        "SELECT serial_number, revoked_at, reason FROM revocations WHERE serial_number = $1",
        serialHex,
    ).Scan(&entry.SerialNumber, &entry.RevokedAt, &entry.Reason)
    
    if err == sql.ErrNoRows {
        // Not revoked, cache the result
        r.redis.Set(ctx, fmt.Sprintf("revoked:%s", serialHex), "false", 1*time.Hour)
        return false, nil
    }
    
    if err != nil {
        return false, err
    }
    
    // Certificate is revoked, cache the result
    r.redis.Set(ctx, fmt.Sprintf("revoked:%s", serialHex), "true", 24*time.Hour)
    return true, nil
}

func (r *RevocationClient) RevokeCertificate(serialNumber string, reason string) error {
    ctx := context.Background()
    
    // Insert into database
    _, err := r.postgres.ExecContext(ctx,
        "INSERT INTO revocations (serial_number, revoked_at, reason) VALUES ($1, $2, $3)",
        serialNumber, time.Now(), reason,
    )
    if err != nil {
        return err
    }
    
    // Update cache
    r.redis.Set(ctx, fmt.Sprintf("revoked:%s", serialNumber), "true", 24*time.Hour)
    
    // Update CRL
    return r.updateCRL()
}

func (r *RevocationClient) updateCRL() error {
    // Generate new CRL
    revokedCerts := []pkix.RevokedCertificate{}
    
    rows, err := r.postgres.Query("SELECT serial_number, revoked_at FROM revocations")
    if err != nil {
        return err
    }
    defer rows.Close()
    
    for rows.Next() {
        var serialHex string
        var revokedAt time.Time
        
        if err := rows.Scan(&serialHex, &revokedAt); err != nil {
            continue
        }
        
        serialBytes, _ := hex.DecodeString(serialHex)
        serial := new(big.Int).SetBytes(serialBytes)
        
        revokedCerts = append(revokedCerts, pkix.RevokedCertificate{
            SerialNumber:   serial,
            RevocationTime: revokedAt,
        })
    }
    
    // Create CRL
    crlBytes, err := x509.CreateCRL(
        rand.Reader,
        &x509.RevocationList{
            RevokedCertificates: revokedCerts,
            Number:              big.NewInt(time.Now().Unix()),
            ThisUpdate:          time.Now(),
            NextUpdate:          time.Now().Add(24 * time.Hour),
        },
        intermediateCA.Certificate,
        intermediateCA.PrivateKey,
    )
    
    // Store CRL
    return r.storeCRL(crlBytes)
}
```

### Step 7: Create gRPC/REST API

```go
// internal/api/grpc.go
package api

import (
    "context"
    
    pb "github.com/mentatlab/pki/proto"
    "google.golang.org/grpc"
)

type PKIService struct {
    pb.UnimplementedPKIServiceServer
    issuer   *CertificateIssuer
    verifier *ManifestVerifier
}

func (s *PKIService) RequestCertificate(ctx context.Context, req *pb.CertificateRequest) (*pb.CertificateResponse, error) {
    // Validate request
    if req.Email == "" {
        return nil, status.Error(codes.InvalidArgument, "email is required")
    }
    
    // Parse public key
    pubKeyBlock, _ := pem.Decode([]byte(req.PublicKeyPem))
    if pubKeyBlock == nil {
        return nil, status.Error(codes.InvalidArgument, "invalid public key")
    }
    
    pubKey, err := x509.ParsePKIXPublicKey(pubKeyBlock.Bytes)
    if err != nil {
        return nil, status.Error(codes.InvalidArgument, "failed to parse public key")
    }
    
    // Issue certificate
    cert, err := s.issuer.IssueDeveloperCert(&DeveloperCertRequest{
        Email:        req.Email,
        PublicKey:    pubKey.(*rsa.PublicKey),
        ValidityDays: 365,
    })
    if err != nil {
        return nil, status.Error(codes.Internal, err.Error())
    }
    
    // Build response
    certPEM := pem.EncodeToMemory(&pem.Block{
        Type:  "CERTIFICATE",
        Bytes: cert.Raw,
    })
    
    return &pb.CertificateResponse{
        Certificate: string(certPEM),
        SerialNumber: cert.SerialNumber.String(),
        ExpiresAt:    cert.NotAfter.Unix(),
    }, nil
}

func (s *PKIService) VerifyManifest(ctx context.Context, req *pb.VerifyRequest) (*pb.VerifyResponse, error) {
    // Parse manifest
    var manifest SignedManifest
    if err := yaml.Unmarshal([]byte(req.ManifestYaml), &manifest); err != nil {
        return nil, status.Error(codes.InvalidArgument, "invalid manifest")
    }
    
    // Verify
    result, err := s.verifier.VerifyManifest(&manifest)
    if err != nil {
        return nil, status.Error(codes.Internal, err.Error())
    }
    
    return &pb.VerifyResponse{
        Valid:       result.Valid,
        Error:       result.Error,
        Signer:      result.Signer,
        SignerEmail: result.SignerEmail,
        TrustLevel:  result.TrustLevel,
    }, nil
}

// REST API wrapper
func (s *PKIService) SetupRESTAPI(router *gin.Engine) {
    router.POST("/v1/certificates/request", s.handleCertRequest)
    router.POST("/v1/manifests/verify", s.handleVerify)
    router.GET("/v1/certificates/:serial", s.handleGetCert)
    router.POST("/v1/certificates/:serial/revoke", s.handleRevoke)
    router.GET("/v1/crl", s.handleGetCRL)
}
```

---

## Certificate Management

### Developer Certificate Lifecycle

```bash
# 1. Generate key pair
openssl genrsa -out developer.key 2048

# 2. Create certificate request
mentatctl pki request-cert \
  --email developer@company.com \
  --key developer.key \
  --output developer.crt

# 3. View certificate details
openssl x509 -in developer.crt -text -noout

# 4. Renew certificate (30 days before expiry)
mentatctl pki renew-cert \
  --cert developer.crt \
  --key developer.key
```

### Certificate Storage Best Practices

```yaml
# ~/.mentat/pki/config.yaml
storage:
  certificates:
    path: ~/.mentat/pki/certs
    permissions: 0600
  
  private_keys:
    path: ~/.mentat/pki/private
    permissions: 0600
    encrypted: true
  
  backup:
    enabled: true
    location: s3://company-backup/mentat-pki/
    retention_days: 365

security:
  key_encryption:
    algorithm: AES-256-GCM
    derive_from: password
  
  auto_lock:
    idle_minutes: 15
    require_auth: true
```

### Certificate Rotation

```go
// Automated certificate rotation
type CertificateRotator struct {
    Store    CertificateStore
    Notifier NotificationService
}

func (r *CertificateRotator) CheckExpiringCerts() error {
    certs, err := r.Store.GetExpiringCerts(30 * 24 * time.Hour)
    if err != nil {
        return err
    }
    
    for _, cert := range certs {
        // Notify owner
        r.Notifier.SendExpiryWarning(cert)
        
        // Auto-renew if enabled
        if cert.AutoRenewEnabled {
            newCert, err := r.renewCertificate(cert)
            if err != nil {
                log.Error("Failed to auto-renew", "cert", cert.Subject, "error", err)
                continue
            }
            
            r.Notifier.SendRenewalSuccess(newCert)
        }
    }
    
    return nil
}
```

---

## Integration with CI/CD

### GitHub Actions Integration

```yaml
# .github/workflows/sign-agents.yml
name: Sign Agent Manifests

on:
  push:
    paths:
      - 'agents/**/manifest.yaml'

jobs:
  sign-manifests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup MentatLab CLI
        run: |
          curl -L https://github.com/mentatlab/cli/releases/latest/download/mentatctl-linux-amd64 -o mentatctl
          chmod +x mentatctl
          sudo mv mentatctl /usr/local/bin/
      
      - name: Configure PKI
        env:
          PKI_ENDPOINT: ${{ secrets.PKI_ENDPOINT }}
          SIGNING_KEY: ${{ secrets.AGENT_SIGNING_KEY }}
        run: |
          mentatctl pki configure \
            --endpoint "$PKI_ENDPOINT" \
            --key-env SIGNING_KEY
      
      - name: Sign manifests
        run: |
          for manifest in $(find agents -name manifest.yaml); do
            echo "Signing $manifest"
            mentatctl sign --manifest "$manifest" --in-place
          done
      
      - name: Verify signatures
        run: |
          for manifest in $(find agents -name manifest.yaml); do
            echo "Verifying $manifest"
            mentatctl verify --manifest "$manifest"
          done
      
      - name: Commit signed manifests
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add agents/**/manifest.yaml
          git commit -m "Sign agent manifests [skip ci]" || exit 0
          git push
```

### GitLab CI Integration

```yaml
# .gitlab-ci.yml
sign-agents:
  stage: sign
  image: mentatlab/cli:latest
  before_script:
    - mentatctl pki configure --endpoint "$PKI_ENDPOINT"
  script:
    - |
      for manifest in $(find agents -name manifest.yaml); do
        mentatctl sign \
          --manifest "$manifest" \
          --cert "$SIGNING_CERT" \
          --key "$SIGNING_KEY" \
          --in-place
      done
  only:
    changes:
      - agents/**/manifest.yaml
```

### Jenkins Pipeline

```groovy
pipeline {
    agent any
    
    environment {
        PKI_ENDPOINT = credentials('pki-endpoint')
        SIGNING_CERT = credentials('agent-signing-cert')
        SIGNING_KEY = credentials('agent-signing-key')
    }
    
    stages {
        stage('Sign Manifests') {
            steps {
                script {
                    def manifests = sh(
                        script: "find agents -name manifest.yaml",
                        returnStdout: true
                    ).trim().split('\n')
                    
                    manifests.each { manifest ->
                        sh """
                            mentatctl sign \
                                --manifest ${manifest} \
                                --cert \$SIGNING_CERT \
                                --key \$SIGNING_KEY \
                                --in-place
                        """
                    }
                }
            }
        }
        
        stage('Verify') {
            steps {
                sh 'mentatctl verify agents/**/manifest.yaml'
            }
        }
    }
}
```

---

## Security Operations

### Key Management

```bash
# Key storage structure
~/.mentat/pki/
├── private/
│   ├── developer.key.enc    # Encrypted private key
│   └── keyring.db          # Key metadata
├── certs/
│   ├── developer.crt       # Developer certificate
│   └── chain.pem          # Certificate chain
└── config.yaml            # PKI configuration
```

### Hardware Security Module (HSM) Support

```go
// HSM integration for high-security environments
type HSMKeyManager struct {
    client *pkcs11.Client
    pin    string
}

func (h *HSMKeyManager) GenerateKey(label string) (*KeyHandle, error) {
    // Generate key pair in HSM
    pubKey, privKey, err := h.client.GenerateKeyPair(
        pkcs11.KeyPairRequest{
            Label:       label,
            KeyType:     pkcs11.RSA,
            KeyBits:     2048,
            Extractable: false,
            Token:       true,
        },
    )
    
    return &KeyHandle{
        PublicKey:  pubKey,
        PrivateKey: privKey,
        InHSM:      true,
    }, err
}

func (h *HSMKeyManager) Sign(handle *KeyHandle, data []byte) ([]byte, error) {
    // Sign using HSM
    return h.client.Sign(
        handle.PrivateKey,
        pkcs11.SignRequest{
            Mechanism: pkcs11.SHA256_RSA_PKCS,
            Data:      data,
        },
    )
}
```

### Security Monitoring

```yaml
# Prometheus alerts for PKI monitoring
groups:
  - name: pki_security
    rules:
      - alert: CertificateExpiringSOon
        expr: pki_certificate_expiry_days < 30
        for: 1h
        annotations:
          summary: "Certificate expiring soon"
          description: "Certificate {{ $labels.subject }} expires in {{ $value }} days"
      
      - alert: UnauthorizedCertRequest
        expr: rate(pki_cert_request_denied_total[5m]) > 0.1
        for: 5m
        annotations:
          summary: "High rate of denied certificate requests"
          description: "{{ $value }} denied requests per second"
      
      - alert: RevokedCertUsage
        expr: pki_revoked_cert_usage_total > 0
        for: 1m
        annotations:
          summary: "Revoked certificate usage detected"
          description: "Revoked certificate {{ $labels.serial }} was used"
```

### Audit Logging

```go
type AuditLogger struct {
    output io.Writer
}

func (a *AuditLogger) LogCertificateIssued(cert *x509.Certificate, requester string) {
    entry := AuditEntry{
        Timestamp: time.Now().UTC(),
        Event:     "certificate.issued",
        Actor:     requester,
        Details: map[string]interface{}{
            "serial":    cert.SerialNumber.String(),
            "subject":   cert.Subject.String(),
            "notBefore": cert.NotBefore,
            "notAfter":  cert.NotAfter,
        },
    }
    
    json.NewEncoder(a.output).Encode(entry)
}

func (a *AuditLogger) LogVerificationResult(manifest string, result *VerificationResult) {
    entry := AuditEntry{
        Timestamp: time.Now().UTC(),
        Event:     "manifest.verified",
        Details: map[string]interface{}{
            "manifest":   manifest,
            "valid":      result.Valid,
            "signer":     result.Signer,
            "trustLevel": result.TrustLevel,
            "error":      result.Error,
        },
    }
    
    json.NewEncoder(a.output).Encode(entry)
}
```

---

## Troubleshooting

### Common Issues

#### Certificate Chain Validation Failures

```bash
# Debug certificate chain
openssl verify -CAfile root-ca.crt -untrusted intermediate-ca.crt developer.crt

# View certificate details
openssl x509 -in developer.crt -text -noout | grep -E "(Subject:|Issuer:|Not Before:|Not After:)"

# Check certificate extensions
openssl x509 -in developer.crt -text -noout | grep -A 10 "X509v3 extensions:"
```

#### Signature Verification Failures

```go
// Enhanced error reporting
func (v *ManifestVerifier) verifySignatureWithDetails(manifest *SignedManifest, cert *x509.Certificate) error {
    canonical, err := canonicalizeManifest(manifest.Manifest)
    if err != nil {
        return fmt.Errorf("canonicalization failed: %w", err)
    }
    
    // Log canonical form for debugging
    log.Debug("Canonical manifest", "data", string(canonical))
    
    signature, err := base64.StdEncoding.DecodeString(manifest.Attestation.Signature)
    if err != nil {
        return fmt.Errorf("signature decode failed: %w", err)
    }
    
    hash := sha256.Sum256(canonical)
    log.Debug("Manifest hash", "hash", hex.EncodeToString(hash[:]))
    
    err = rsa.VerifyPKCS1v15(cert.PublicKey.(*rsa.PublicKey), crypto.SHA256, hash[:], signature)
    if err != nil {
        return fmt.Errorf("signature verification failed: %w", err)
    }
    
    return nil
}
```

#### Revocation Check Failures

```bash
# Test OCSP responder
openssl ocsp \
  -CAfile ca-chain.pem \
  -url http://ocsp.mentatlab.com \
  -resp_text \
  -issuer intermediate-ca.crt \
  -cert developer.crt

# Check CRL
curl -O http://crl.mentatlab.com/agent-ca.crl
openssl crl -in agent-ca.crl -text -noout
```

### Performance Optimization

```go
// Concurrent verification for bulk operations
func (v *ManifestVerifier) VerifyBatch(manifests []string) []VerificationResult {
    results := make([]VerificationResult, len(manifests))
    var wg sync.WaitGroup
    
    // Use worker pool
    workers := runtime.NumCPU()
    jobs := make(chan int, len(manifests))
    
    for w := 0; w < workers; w++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for i := range jobs {
                result, _ := v.VerifyManifest(manifests[i])
                results[i] = *result
            }
        }()
    }
    
    // Queue jobs
    for i := range manifests {
        jobs <- i
    }
    close(jobs)
    
    wg.Wait()
    return results
}
```

---

## Best Practices

### Development
1. Never commit private keys to version control
2. Use hardware tokens for production signing
3. Implement key rotation policies
4. Monitor certificate expiration

### Operations
1. Automate certificate renewal
2. Maintain offline root CA
3. Regular security audits
4. Implement break-glass procedures

### Security
1. Use strong key sizes (RSA 2048+ or ECC P-256+)
2. Implement certificate pinning for critical agents
3. Monitor for unauthorized certificate usage
4. Regular penetration testing

---

This implementation guide provides a complete framework for establishing a robust PKI infrastructure for MentatLab v1.0, ensuring cryptographic trust and security for all agent deployments.