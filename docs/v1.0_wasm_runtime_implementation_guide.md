# WASM Runtime Implementation Guide
## MentatLab v1.0

*Version: 1.0*  
*Date: August 1, 2025*

---

## Table of Contents
1. [Overview](#overview)
2. [Prerequisites](#prerequisites)
3. [Architecture Components](#architecture-components)
4. [Implementation Steps](#implementation-steps)
5. [Integration Points](#integration-points)
6. [Testing Strategy](#testing-strategy)
7. [Performance Tuning](#performance-tuning)
8. [Troubleshooting](#troubleshooting)

---

## Overview

This guide provides step-by-step instructions for implementing the WebAssembly runtime in MentatLab v1.0. The WASM runtime enables sandboxed execution of agents with near-native performance and polyglot language support.

### Goals
- Integrate Wasmtime as the primary WASM engine
- Implement the host API for WASM modules
- Create the capability-based security system
- Enable dual runtime support (WASM + containers)

---

## Prerequisites

### Development Environment
```bash
# Install Rust and cargo
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Install Wasmtime
curl https://wasmtime.dev/install.sh -sSf | bash

# Install wasm-tools
cargo install wasm-tools

# Install language-specific tools
npm install -g assemblyscript
go install github.com/tinygo-org/tinygo@latest
```

### Dependencies
```toml
# Cargo.toml for the WASM runtime service
[dependencies]
wasmtime = "14.0"
wasmtime-wasi = "14.0"
anyhow = "1.0"
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
tracing = "0.1"
cap-std = "2.0"  # For capability-based filesystem
```

---

## Architecture Components

### 1. Core Runtime Structure

```
services/wasm-runtime/
├── Cargo.toml
├── src/
│   ├── main.rs           # Service entry point
│   ├── runtime/
│   │   ├── mod.rs        # Runtime module
│   │   ├── engine.rs     # Wasmtime engine wrapper
│   │   ├── instance.rs   # WASM instance management
│   │   └── pool.rs       # Memory/instance pooling
│   ├── host/
│   │   ├── mod.rs        # Host API module
│   │   ├── api.rs        # Host function implementations
│   │   ├── capabilities.rs # Capability system
│   │   └── sandbox.rs    # Sandbox configuration
│   ├── security/
│   │   ├── mod.rs        # Security module
│   │   ├── policy.rs     # Policy engine
│   │   └── audit.rs      # Audit logging
│   └── grpc/
│       ├── mod.rs        # gRPC service
│       └── proto/        # Protocol definitions
```

---

## Implementation Steps

### Step 1: Create the Wasmtime Engine Wrapper

```rust
// services/wasm-runtime/src/runtime/engine.rs
use wasmtime::*;
use wasmtime_wasi::WasiCtxBuilder;
use std::sync::Arc;

pub struct WasmEngine {
    engine: Engine,
    compiler_config: Config,
    linker: Linker<HostContext>,
}

impl WasmEngine {
    pub fn new() -> Result<Self> {
        // Configure Wasmtime engine
        let mut config = Config::new();
        
        // Enable optimizations
        config.cranelift_opt_level(OptLevel::Speed);
        config.cache_config_load_default()?;
        config.parallel_compilation(true);
        
        // Security settings
        config.consume_fuel(true);  // Enable fuel for CPU limits
        config.memory_init_cow(true);  // Copy-on-write for memory
        
        let engine = Engine::new(&config)?;
        let mut linker = Linker::new(&engine);
        
        // Add WASI support
        wasmtime_wasi::add_to_linker(&mut linker, |ctx: &mut HostContext| &mut ctx.wasi)?;
        
        Ok(Self {
            engine,
            compiler_config: config,
            linker,
        })
    }
    
    pub async fn load_module(&self, wasm_bytes: &[u8]) -> Result<Module> {
        // Validate WASM module
        wasmtime::Module::validate(&self.engine, wasm_bytes)?;
        
        // Compile module (uses cache if available)
        let module = Module::new(&self.engine, wasm_bytes)?;
        
        // Verify imports match our host API
        self.validate_imports(&module)?;
        
        Ok(module)
    }
}
```

### Step 2: Implement Host API

```rust
// services/wasm-runtime/src/host/api.rs
use wasmtime::*;
use std::sync::Arc;
use tokio::sync::Mutex;

pub struct HostContext {
    pub wasi: WasiCtx,
    pub agent_id: String,
    pub input_data: Arc<Mutex<Vec<u8>>>,
    pub output_data: Arc<Mutex<Vec<u8>>>,
    pub capabilities: CapabilitySet,
    pub metrics: MetricsCollector,
}

pub fn setup_host_functions(linker: &mut Linker<HostContext>) -> Result<()> {
    // Input/Output functions
    linker.func_wrap("mentat", "read_input", |mut caller: Caller<'_, HostContext>| -> i32 {
        let ctx = caller.data_mut();
        let input = ctx.input_data.blocking_lock();
        
        // Write input to WASM memory
        let memory = caller.get_export("memory").unwrap().into_memory().unwrap();
        let ptr = 0;  // Simplified - real impl needs proper allocation
        memory.write(&mut caller, ptr, &input)?;
        
        ptr as i32
    })?;
    
    linker.func_wrap("mentat", "write_output", 
        |mut caller: Caller<'_, HostContext>, ptr: i32, len: i32| -> i32 {
        let memory = caller.get_export("memory").unwrap().into_memory().unwrap();
        let mut buffer = vec![0u8; len as usize];
        memory.read(&caller, ptr as usize, &mut buffer)?;
        
        let ctx = caller.data_mut();
        *ctx.output_data.blocking_lock() = buffer;
        
        0  // Success
    })?;
    
    // Logging function
    linker.func_wrap("mentat", "log",
        |mut caller: Caller<'_, HostContext>, level: i32, ptr: i32, len: i32| {
        let memory = caller.get_export("memory").unwrap().into_memory().unwrap();
        let mut buffer = vec![0u8; len as usize];
        memory.read(&caller, ptr as usize, &mut buffer)?;
        
        let message = String::from_utf8_lossy(&buffer);
        let level = match level {
            0 => tracing::Level::ERROR,
            1 => tracing::Level::WARN,
            2 => tracing::Level::INFO,
            3 => tracing::Level::DEBUG,
            _ => tracing::Level::TRACE,
        };
        
        tracing::event!(level, agent_id = %caller.data().agent_id, "{}", message);
    })?;
    
    // Capability system
    linker.func_wrap("mentat", "request_capability",
        |mut caller: Caller<'_, HostContext>, cap_ptr: i32, cap_len: i32| -> i32 {
        let memory = caller.get_export("memory").unwrap().into_memory().unwrap();
        let mut buffer = vec![0u8; cap_len as usize];
        memory.read(&caller, cap_ptr as usize, &mut buffer)?;
        
        let capability_str = String::from_utf8_lossy(&buffer);
        let ctx = caller.data_mut();
        
        match ctx.capabilities.request(&capability_str) {
            Ok(handle) => handle as i32,
            Err(_) => -1,  // Error
        }
    })?;
    
    // Multimodal operations
    linker.func_wrap_async("mentat", "download_media",
        |mut caller: Caller<'_, HostContext>, ref_ptr: i32, ref_len: i32| -> Box<dyn Future<Output = i32> + Send> {
        Box::new(async move {
            // Implementation for downloading from S3/object storage
            let memory = caller.get_export("memory").unwrap().into_memory().unwrap();
            let mut buffer = vec![0u8; ref_len as usize];
            memory.read(&caller, ref_ptr as usize, &mut buffer)?;
            
            let reference = String::from_utf8_lossy(&buffer);
            let data = download_from_storage(&reference).await?;
            
            // Write to WASM memory
            let ptr = allocate_in_wasm(&mut caller, data.len())?;
            memory.write(&mut caller, ptr, &data)?;
            
            ptr as i32
        })
    })?;
    
    Ok(())
}
```

### Step 3: Implement Capability System

```rust
// services/wasm-runtime/src/host/capabilities.rs
use std::collections::HashMap;
use std::path::PathBuf;

#[derive(Debug, Clone)]
pub enum Capability {
    FileSystem { path: PathBuf, mode: AccessMode },
    Network { pattern: String, protocols: Vec<String> },
    Environment { var: String },
    Compute { max_memory: usize, max_cpu_ms: u64 },
}

#[derive(Debug, Clone, Copy)]
pub enum AccessMode {
    ReadOnly,
    ReadWrite,
    WriteOnly,
}

pub struct CapabilitySet {
    manifest_capabilities: Vec<Capability>,
    granted: HashMap<u32, Capability>,
    next_handle: u32,
    policy_engine: PolicyEngine,
}

impl CapabilitySet {
    pub fn new(manifest_capabilities: Vec<Capability>) -> Self {
        Self {
            manifest_capabilities,
            granted: HashMap::new(),
            next_handle: 1,
            policy_engine: PolicyEngine::new(),
        }
    }
    
    pub fn request(&mut self, capability_str: &str) -> Result<u32, CapabilityError> {
        // Parse capability string
        let requested_cap = self.parse_capability(capability_str)?;
        
        // Check if allowed by manifest
        if !self.is_allowed_by_manifest(&requested_cap) {
            return Err(CapabilityError::NotInManifest);
        }
        
        // Runtime policy check
        if !self.policy_engine.evaluate(&requested_cap) {
            return Err(CapabilityError::PolicyDenied);
        }
        
        // Grant capability
        let handle = self.next_handle;
        self.next_handle += 1;
        self.granted.insert(handle, requested_cap);
        
        // Audit log
        audit_log!("capability_granted", {
            "handle": handle,
            "capability": capability_str,
            "timestamp": Utc::now(),
        });
        
        Ok(handle)
    }
    
    pub fn invoke(&self, handle: u32, operation: &str) -> Result<(), CapabilityError> {
        let capability = self.granted.get(&handle)
            .ok_or(CapabilityError::InvalidHandle)?;
        
        // Verify operation is allowed by capability
        match capability {
            Capability::FileSystem { path, mode } => {
                self.check_filesystem_access(path, mode, operation)?;
            }
            Capability::Network { pattern, .. } => {
                self.check_network_access(pattern, operation)?;
            }
            // ... other capability types
        }
        
        Ok(())
    }
}
```

### Step 4: Create Sandbox Configuration

```rust
// services/wasm-runtime/src/host/sandbox.rs
use wasmtime_wasi::{WasiCtxBuilder, Dir, ambient_authority};
use cap_std::fs::Dir as CapDir;

pub struct SandboxConfig {
    pub memory_limit: usize,
    pub cpu_fuel: u64,
    pub allowed_paths: Vec<(PathBuf, AccessMode)>,
    pub env_vars: HashMap<String, String>,
    pub network_rules: NetworkRules,
}

impl SandboxConfig {
    pub fn from_manifest(manifest: &AgentManifest) -> Self {
        Self {
            memory_limit: manifest.wasm.memory.maximum * 1024 * 1024,
            cpu_fuel: 1_000_000_000,  // 1 billion instructions
            allowed_paths: Self::parse_paths(&manifest.wasm.capabilities),
            env_vars: Self::filter_env_vars(&manifest.wasm.capabilities),
            network_rules: NetworkRules::from_capabilities(&manifest.wasm.capabilities),
        }
    }
    
    pub fn build_wasi_context(&self) -> Result<WasiCtx> {
        let mut builder = WasiCtxBuilder::new();
        
        // Configure filesystem access
        for (path, mode) in &self.allowed_paths {
            let dir = match mode {
                AccessMode::ReadOnly => {
                    Dir::open_ambient_dir(path, ambient_authority())?
                        .readonly()
                },
                AccessMode::ReadWrite => {
                    Dir::open_ambient_dir(path, ambient_authority())?
                },
                AccessMode::WriteOnly => {
                    // Custom implementation for write-only
                    Dir::open_ambient_dir(path, ambient_authority())?
                        .writeonly()
                }
            };
            
            builder.preopened_dir(dir, path)?;
        }
        
        // Set environment variables
        for (key, value) in &self.env_vars {
            builder.env(key, value);
        }
        
        // Inherit stdio for debugging
        builder.inherit_stdio();
        
        Ok(builder.build())
    }
}

pub struct NetworkRules {
    allowed_hosts: Vec<String>,
    blocked_ports: Vec<u16>,
    max_connections: usize,
}

impl NetworkRules {
    pub fn check_connection(&self, host: &str, port: u16) -> bool {
        // Check if host matches allowed patterns
        let host_allowed = self.allowed_hosts.iter().any(|pattern| {
            if pattern.starts_with("*.") {
                host.ends_with(&pattern[2..])
            } else {
                host == pattern
            }
        });
        
        let port_allowed = !self.blocked_ports.contains(&port);
        
        host_allowed && port_allowed
    }
}
```

### Step 5: Implement Instance Management

```rust
// services/wasm-runtime/src/runtime/instance.rs
use wasmtime::*;
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct WasmInstance {
    instance: Instance,
    store: Store<HostContext>,
    memory: Memory,
    fuel_consumed: Arc<RwLock<u64>>,
}

impl WasmInstance {
    pub async fn new(
        engine: &Engine,
        module: &Module,
        linker: &Linker<HostContext>,
        context: HostContext,
    ) -> Result<Self> {
        let mut store = Store::new(engine, context);
        
        // Set resource limits
        store.limiter(|ctx| &mut ctx.limiter);
        store.add_fuel(ctx.sandbox_config.cpu_fuel)?;
        
        // Instantiate module
        let instance = linker.instantiate_async(&mut store, module).await?;
        
        // Get memory export
        let memory = instance
            .get_memory(&mut store, "memory")
            .ok_or_else(|| anyhow!("No memory export found"))?;
        
        Ok(Self {
            instance,
            store,
            memory,
            fuel_consumed: Arc::new(RwLock::new(0)),
        })
    }
    
    pub async fn call_process(&mut self) -> Result<i32> {
        // Get the process function
        let process = self.instance
            .get_typed_func::<(), i32>(&mut self.store, "process")?;
        
        // Record start metrics
        let start_fuel = self.store.fuel_consumed().unwrap_or(0);
        let start_time = Instant::now();
        
        // Call the function
        let result = process.call_async(&mut self.store, ()).await?;
        
        // Record metrics
        let fuel_used = self.store.fuel_consumed().unwrap_or(0) - start_fuel;
        let duration = start_time.elapsed();
        
        *self.fuel_consumed.write().await = fuel_used;
        
        metrics::histogram!("wasm_execution_duration_seconds", duration.as_secs_f64());
        metrics::counter!("wasm_fuel_consumed_total", fuel_used);
        
        Ok(result)
    }
    
    pub fn get_memory_usage(&self) -> usize {
        self.memory.data_size(&self.store)
    }
}
```

### Step 6: Create Memory Pool

```rust
// services/wasm-runtime/src/runtime/pool.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;

pub struct MemoryPool {
    pools: Arc<Mutex<HashMap<usize, Vec<Memory>>>>,
    max_total_memory: usize,
    current_usage: Arc<Mutex<usize>>,
}

impl MemoryPool {
    pub fn new(max_total_memory: usize) -> Self {
        Self {
            pools: Arc::new(Mutex::new(HashMap::new())),
            max_total_memory,
            current_usage: Arc::new(Mutex::new(0)),
        }
    }
    
    pub async fn allocate(&self, pages: u64) -> Result<PooledMemory> {
        let size = pages as usize * WASM_PAGE_SIZE;
        
        // Check total memory limit
        let mut current = self.current_usage.lock().await;
        if *current + size > self.max_total_memory {
            return Err(MemoryError::OutOfMemory);
        }
        
        // Try to get from pool
        let mut pools = self.pools.lock().await;
        if let Some(pool) = pools.get_mut(&size) {
            if let Some(memory) = pool.pop() {
                return Ok(PooledMemory {
                    memory,
                    pool: self.clone(),
                    size,
                });
            }
        }
        
        // Allocate new memory
        let memory = Memory::new(&ENGINE, MemoryType::new(pages, Some(pages)))?;
        *current += size;
        
        Ok(PooledMemory {
            memory,
            pool: self.clone(),
            size,
        })
    }
    
    async fn release(&self, memory: Memory, size: usize) {
        // Clear memory for security
        unsafe {
            let data = memory.data_unchecked_mut();
            data.fill(0);
        }
        
        // Return to pool
        let mut pools = self.pools.lock().await;
        pools.entry(size).or_insert_with(Vec::new).push(memory);
    }
}

pub struct PooledMemory {
    memory: Memory,
    pool: MemoryPool,
    size: usize,
}

impl Drop for PooledMemory {
    fn drop(&mut self) {
        let pool = self.pool.clone();
        let memory = self.memory.clone();
        let size = self.size;
        
        tokio::spawn(async move {
            pool.release(memory, size).await;
        });
    }
}
```

### Step 7: Implement gRPC Service

```rust
// services/wasm-runtime/src/grpc/service.rs
use tonic::{Request, Response, Status};

pub struct WasmRuntimeService {
    engine: Arc<WasmEngine>,
    instance_manager: Arc<InstanceManager>,
    module_cache: Arc<ModuleCache>,
}

#[tonic::async_trait]
impl WasmRuntime for WasmRuntimeService {
    async fn load_agent(
        &self,
        request: Request<LoadAgentRequest>,
    ) -> Result<Response<LoadAgentResponse>, Status> {
        let req = request.into_inner();
        
        // Verify attestation if present
        if let Some(attestation) = &req.attestation {
            verify_attestation(attestation).await
                .map_err(|e| Status::unauthenticated(e.to_string()))?;
        }
        
        // Load WASM module
        let module = if let Some(cached) = self.module_cache.get(&req.agent_id).await {
            cached
        } else {
            let module = self.engine.load_module(&req.wasm_bytes).await
                .map_err(|e| Status::invalid_argument(e.to_string()))?;
            
            self.module_cache.insert(req.agent_id.clone(), module.clone()).await;
            module
        };
        
        Ok(Response::new(LoadAgentResponse {
            agent_id: req.agent_id,
            module_hash: calculate_hash(&req.wasm_bytes),
            capabilities_required: extract_capabilities(&module),
        }))
    }
    
    async fn execute_agent(
        &self,
        request: Request<ExecuteAgentRequest>,
    ) -> Result<Response<ExecuteAgentResponse>, Status> {
        let req = request.into_inner();
        
        // Create execution context
        let context = HostContext {
            agent_id: req.agent_id.clone(),
            input_data: Arc::new(Mutex::new(req.input)),
            output_data: Arc::new(Mutex::new(Vec::new())),
            capabilities: CapabilitySet::from_manifest(&req.manifest),
            wasi: build_wasi_context(&req.sandbox_config)?,
            metrics: MetricsCollector::new(),
        };
        
        // Get or create instance
        let mut instance = self.instance_manager
            .get_or_create(&req.agent_id, context).await?;
        
        // Execute
        let result = instance.call_process().await
            .map_err(|e| Status::internal(e.to_string()))?;
        
        // Get output
        let output = instance.store.data().output_data.lock().await.clone();
        
        Ok(Response::new(ExecuteAgentResponse {
            output,
            exit_code: result,
            metrics: instance.store.data().metrics.collect(),
        }))
    }
}
```

---

## Integration Points

### 1. Orchestrator Integration

```python
# services/orchestrator/app/runtime_selector.py
class RuntimeSelector:
    def __init__(self):
        self.wasm_client = WasmRuntimeClient()
        self.container_runtime = ContainerRuntime()
    
    async def execute_node(self, node: AgentNode, input_data: bytes) -> bytes:
        """Execute agent node using appropriate runtime"""
        
        manifest = await self.load_manifest(node.agent_id)
        
        if manifest.runtime == "wasm":
            # Use WASM runtime
            return await self.execute_wasm(node, manifest, input_data)
        else:
            # Fall back to container runtime
            return await self.execute_container(node, manifest, input_data)
    
    async def execute_wasm(self, node: AgentNode, manifest: Manifest, input_data: bytes) -> bytes:
        # Load agent if not cached
        if not await self.wasm_client.is_loaded(node.agent_id):
            wasm_bytes = await self.fetch_wasm_module(node.agent_id)
            await self.wasm_client.load_agent(
                agent_id=node.agent_id,
                wasm_bytes=wasm_bytes,
                attestation=manifest.attestation
            )
        
        # Execute
        response = await self.wasm_client.execute_agent(
            agent_id=node.agent_id,
            input=input_data,
            manifest=manifest,
            sandbox_config=self.build_sandbox_config(manifest)
        )
        
        return response.output
```

### 2. Gateway WebSocket Integration

```python
# services/gateway/app/websockets.py
class EnhancedConnectionManager(ConnectionManager):
    async def handle_wasm_streaming(self, stream_id: str, agent_id: str):
        """Handle streaming from WASM agents"""
        
        # Subscribe to WASM runtime stream events
        async for event in self.wasm_runtime.stream_events(stream_id):
            if event.type == "data":
                await self.broadcast_to_subscribers(stream_id, {
                    "type": "stream_data",
                    "data": event.data,
                    "sequence": event.sequence
                })
            elif event.type == "end":
                await self.broadcast_to_subscribers(stream_id, {
                    "type": "stream_end",
                    "total_chunks": event.total_chunks
                })
                break
```

---

## Testing Strategy

### 1. Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_basic_wasm_execution() {
        let engine = WasmEngine::new().unwrap();
        let wasm_bytes = include_bytes!("../test_data/hello_world.wasm");
        
        let module = engine.load_module(wasm_bytes).await.unwrap();
        let context = create_test_context();
        
        let mut instance = WasmInstance::new(&engine, &module, &engine.linker, context)
            .await.unwrap();
        
        let result = instance.call_process().await.unwrap();
        assert_eq!(result, 0);
        
        let output = instance.store.data().output_data.lock().await;
        assert_eq!(*output, b"Hello, World!");
    }
    
    #[tokio::test]
    async fn test_capability_denial() {
        let mut capabilities = CapabilitySet::new(vec![]);
        
        let result = capabilities.request("filesystem:write:/etc/passwd");
        assert!(matches!(result, Err(CapabilityError::NotInManifest)));
    }
    
    #[tokio::test]
    async fn test_memory_limit() {
        let engine = WasmEngine::new().unwrap();
        let wasm_bytes = include_bytes!("../test_data/memory_hog.wasm");
        
        let module = engine.load_module(wasm_bytes).await.unwrap();
        let mut context = create_test_context();
        context.limiter.memory_limit = 1024 * 1024; // 1MB limit
        
        let instance = WasmInstance::new(&engine, &module, &engine.linker, context).await;
        assert!(instance.is_err());
    }
}
```

### 2. Integration Tests

```rust
#[tokio::test]
async fn test_end_to_end_execution() {
    // Start WASM runtime service
    let service = start_test_service().await;
    
    // Load test agent
    let response = service.load_agent(Request::new(LoadAgentRequest {
        agent_id: "test.agent".to_string(),
        wasm_bytes: include_bytes!("../test_data/test_agent.wasm").to_vec(),
        attestation: None,
    })).await.unwrap();
    
    // Execute agent
    let exec_response = service.execute_agent(Request::new(ExecuteAgentRequest {
        agent_id: "test.agent".to_string(),
        input: b"test input".to_vec(),
        manifest: create_test_manifest(),
        sandbox_config: create_test_sandbox_config(),
    })).await.unwrap();
    
    assert_eq!(exec_response.get_ref().exit_code, 0);
    assert!(!exec_response.get_ref().output.is_empty());
}
```

### 3. Security Tests

```rust
#[tokio::test]
async fn test_sandbox_escape_prevention() {
    let tests = vec![
        ("filesystem_escape.wasm", "Filesystem escape should fail"),
        ("network_escape.wasm", "Network escape should fail"),
        ("memory_escape.wasm", "Memory escape should fail"),
    ];
    
    for (wasm_file, description) in tests {
        let wasm_bytes = include_bytes!(&format!("../test_data/security/{}", wasm_file));
        let result = execute_in_sandbox(wasm_bytes).await;
        
        assert!(result.is_err(), "{}", description);
        assert!(matches!(
            result.unwrap_err(),
            ExecutionError::SecurityViolation(_)
        ));
    }
}
```

---

## Performance Tuning

### 1. Module Caching

```rust
pub struct ModuleCache {
    cache: Arc<RwLock<HashMap<String, CachedModule>>>,
    max_size: usize,
    lru: Arc<Mutex<LruCache<String, ()>>>,
}

impl ModuleCache {
    pub async fn get_or_compile(
        &self,
        agent_id: &str,
        wasm_bytes: &[u8],
        engine: &Engine,
    ) -> Result<Module> {
        // Check cache
        if let Some(cached) = self.get(agent_id).await {
            return Ok(cached.module);
        }
        
        // Compile with optimizations
        let start = Instant::now();
        let module = Module::new(engine, wasm_bytes)?;
        let compile_time = start.elapsed();
        
        metrics::histogram!("wasm_compile_duration_seconds", compile_time.as_secs_f64());
        
        // Cache the compiled module
        self.insert(agent_id, module.clone()).await;
        
        Ok(module)
    }
}
```

### 2. Instance Pooling

```rust
pub struct InstancePool {
    available: Arc<Mutex<Vec<PooledInstance>>>,
    max_instances: usize,
    warm_instances: usize,
}

impl InstancePool {
    pub async fn acquire(&self, agent_id: &str) -> Result<PooledInstance> {
        // Try to get warm instance
        let mut available = self.available.lock().await;
        if let Some(instance) = available.iter()
            .position(|i| i.agent_id == agent_id)
            .and_then(|idx| available.swap_remove(idx)) {
            
            return Ok(instance);
        }
        
        // Create new instance
        self.create_instance(agent_id).await
    }
    
    async fn maintain_warm_pool(&self) {
        loop {
            let count = self.available.lock().await.len();
            if count < self.warm_instances {
                // Pre-warm instances for frequently used agents
                for agent_id in self.get_frequent_agents().await {
                    if let Ok(instance) = self.create_instance(&agent_id).await {
                        self.available.lock().await.push(instance);
                    }
                }
            }
            
            tokio::time::sleep(Duration::from_secs(30)).await;
        }
    }
}
```

### 3. Memory Optimization

```rust
impl WasmInstance {
    pub async fn optimize_memory(&mut self) {
        // Shrink memory if possible
        let current_size = self.memory.size(&self.store);
        let used_pages = self.calculate_used_pages();
        
        if used_pages < current_size * 3 / 4 {
            // Memory is underutilized, consider shrinking
            if let Ok(new_memory) = Memory::new(
                &self.store.engine(),
                MemoryType::new(used_pages, Some(current_size))
            ) {
                self.memory = new_memory;
                metrics::counter!("wasm_memory_shrink_total", 1);
            }
        }
    }
}
```

---

## Troubleshooting

### Common Issues

#### 1. Module Compilation Failures
```rust
// Enhanced error handling
match Module::new(&engine, wasm_bytes) {
    Ok(module) => module,
    Err(e) => {
        // Log detailed error
        tracing::error!(
            agent_id = %agent_id,
            error = %e,
            wasm_size = wasm_bytes.len(),
            "Failed to compile WASM module"
        );
        
        // Check common issues
        if e.to_string().contains("unsupported import") {
            return Err(CompileError::UnsupportedImport(extract_imports(&e)));
        } else if e.to_string().contains("memory") {
            return Err(CompileError::MemoryConfiguration);
        }
        
        Err(CompileError::Other(e))
    }
}
```

#### 2. Performance Debugging
```rust
pub struct PerformanceMonitor {
    pub fn trace_execution(&self, instance: &mut WasmInstance) {
        // Enable tracing
        instance.store.tracing_mem_access(true);
        
        // Set up profiling
        let profiler = ProfilerBuilder::new()
            .frequency(1000)  // 1kHz sampling
            .build(&mut instance.store);
        
        // Execute with profiling
        let result = instance.call_process().await?;
        
        // Analyze profile
        let profile = profiler.finish();
        self.analyze_hotspots(&profile);
    }
}
```

#### 3. Memory Leaks
```rust
impl Drop for WasmInstance {
    fn drop(&mut self) {
        // Ensure all resources are cleaned up
        if let Ok(fuel) = self.store.fuel_consumed() {
            metrics::counter!("wasm_fuel_total_consumed", fuel);
        }
        
        // Clear sensitive data
        if let Ok(data) = self.store.data().output_data.try_lock() {
            data.clear();
            data.shrink_to_fit();
        }
        
        tracing::debug!(
            agent_id = %self.store.data().agent_id,
            memory_usage = self.get_memory_usage(),
            "WASM instance dropped"
        );
    }
}
```

### Debugging Tools

#### 1. WASM Debugger Integration
```bash
# Enable debugging in development
export WASMTIME_BACKTRACE_DETAILS=1
export RUST_LOG=wasmtime_runtime=debug,wasm_runtime=trace

# Use wasm-tools for inspection
wasm-tools validate agent.wasm
wasm-tools print agent.wasm | less
```

#### 2. Runtime Metrics Dashboard
```yaml
# Prometheus queries for monitoring
wasm_instances_active:
  query: sum(wasm_instances_total{status="active"})
  
wasm_execution_latency_p99:
  query: histogram_quantile(0.99, wasm_execution_duration_seconds)
  
wasm_memory_efficiency:
  query: rate(wasm_memory_usage_bytes[5m]) / rate(wasm_instances_total[5m])
```

---

## Best Practices

### 1. Module Development
- Keep WASM modules small (< 1MB)
- Minimize imports to reduce attack surface
- Use wasm-opt for size optimization
- Implement proper error handling

### 2. Security
- Always validate capabilities in manifest
- Use minimal sandbox permissions
- Audit all host function calls
- Implement rate limiting

### 3. Performance
- Pre-compile frequently used modules
- Use instance pooling for hot agents
- Monitor memory usage patterns
- Profile before optimizing

### 4. Operations
- Set up comprehensive monitoring
- Implement graceful degradation
- Plan for rollback scenarios
- Test security boundaries

---

This implementation guide provides the foundation for building a robust, secure, and performant WebAssembly runtime for MentatLab v1.0. Follow the steps sequentially and adapt based on your specific requirements and infrastructure.