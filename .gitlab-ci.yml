# MentatLab CI/CD Pipeline
# Uses BuildKit via the central buildkitd service with pre-configured Harbor credentials

include:
  - project: platform/gitops
    ref: main
    file:
      - /k3s/ci/caches/gitlab-ci-cache.yml

stages:
  - lint
  - test
  - build
  - e2e
  - deploy

variables:
  REGISTRY: registry.harbor.lan/library
  BUILDKIT_HOST: "tcp://buildkitd-central.ci-build.svc.cluster.local:1234"
  GO_VERSION: "1.24"
  NODE_VERSION: "20"
  # Work around GitLab advertising an in-cluster clone URL to runners outside the cluster
  GIT_STRATEGY: none
  GITLAB_EXTERNAL_HOST: gitlab.flexinfer.ai

# ==============================================================================
# Reusable Scripts
# ==============================================================================

.apk_add_git: &apk_add_git
  - |
    set -euo pipefail
    if command -v git >/dev/null 2>&1; then
      exit 0
    fi
    if [ ! -s /etc/ssl/certs/ca-certificates.crt ]; then
      echo "Installing CA certificates..."
      sed -i 's#^https:#http:#' /etc/apk/repositories 2>/dev/null || true
      apk add --no-cache ca-certificates || true
      update-ca-certificates || true
      sed -i 's#^http:#https:#' /etc/apk/repositories 2>/dev/null || true
    fi
    for i in 1 2 3; do
      if apk add --no-cache git; then
        exit 0
      fi
      echo "apk add git failed (attempt $i/3); retrying..."
      sleep $((i * 3))
    done
    echo "Falling back to alternate Alpine mirror over HTTP..."
    sed -i 's#https://dl-cdn.alpinelinux.org#http://mirrors.edge.kernel.org#' /etc/apk/repositories
    apk add --no-cache git

.clone_repo: &clone_repo
  - |
    set -euo pipefail
    if [ -d ".git" ] && git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      echo "Repository already present"
      exit 0
    fi
    echo "Cloning via external host ${GITLAB_EXTERNAL_HOST}..."
    git init -q .
    git remote add origin "https://gitlab-ci-token:${CI_JOB_TOKEN}@${GITLAB_EXTERNAL_HOST}/${CI_PROJECT_PATH}.git"
    git fetch -q --depth "${GIT_DEPTH:-20}" origin "${CI_COMMIT_SHA}"
    git checkout -q -f "${CI_COMMIT_SHA}"

# Cache settings
.go-cache: &go-cache
  cache:
    key: go-${CI_COMMIT_REF_SLUG}
    paths:
      - .go/pkg/mod/
    policy: pull-push
    when: on_success

.node-cache: &node-cache
  cache:
    key: node-${CI_COMMIT_REF_SLUG}
    paths:
      - services/frontend/node_modules/
    policy: pull-push
    when: on_success

# ==============================================================================
# LINT STAGE
# ==============================================================================

lint-go:
  stage: lint
  image: golang:${GO_VERSION}-alpine
  <<: *go-cache
  variables:
    GOPATH: $CI_PROJECT_DIR/.go
  before_script:
    - *apk_add_git
    - *clone_repo
  script:
    - (cd services/gateway-go && go mod download && go vet ./...)
    - (cd services/orchestrator-go && go mod download && go vet ./...)
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

lint-frontend:
  stage: lint
  image: node:${NODE_VERSION}-alpine
  <<: *node-cache
  before_script:
    - *apk_add_git
    - *clone_repo
  script:
    - cd services/frontend
    - npm ci --prefer-offline
    - npm run lint
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

# ==============================================================================
# TEST STAGE
# ==============================================================================

test-go:
  stage: test
  image: golang:${GO_VERSION}-alpine
  <<: *go-cache
  variables:
    GOPATH: $CI_PROJECT_DIR/.go
  before_script:
    - *apk_add_git
    - *clone_repo
  script:
    - (cd services/gateway-go && go mod download && go test -v ./...)
    - (cd services/orchestrator-go && go mod download && go test -v ./...)
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

test-frontend:
  stage: test
  image: node:${NODE_VERSION}-alpine
  <<: *node-cache
  before_script:
    - *apk_add_git
    - *clone_repo
  script:
    - cd services/frontend
    - npm ci --prefer-offline
    - npm test
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

# ==============================================================================
# BUILD STAGE
# ==============================================================================

build-images:
  stage: build
  image: registry.harbor.lan/library/ci-builder:latest
  variables:
    BUILDKIT_STEP_LOG_MAX_SIZE: "50000000"
  before_script:
    - *clone_repo
    - |
      echo "Waiting for BuildKit..."
      for i in $(seq 1 30); do
        if buildctl --addr "${BUILDKIT_HOST}" debug info >/dev/null 2>&1; then
          echo "BuildKit is ready"; break
        fi
        echo "[$i/30] not ready yet"; sleep 2
      done
      buildctl --addr "${BUILDKIT_HOST}" debug info
  script:
    - |
      set -euo pipefail
      CACHE_REPO="registry.harbor.lan/library/build-cache"

      build_image() {
        local name="$1" context="$2"
        echo "=== Building ${name} from ${context} ==="

        local tags="--output type=image,push=true"
        tags="${tags},name=${REGISTRY}/${name}:${CI_COMMIT_SHORT_SHA}"

        if [ "$CI_COMMIT_BRANCH" = "main" ]; then
          tags="${tags},name=${REGISTRY}/${name}:latest"
        fi

        buildctl --addr "${BUILDKIT_HOST}" build \
          --frontend dockerfile.v0 \
          --local context="${context}" \
          --local dockerfile="${context}" \
          --opt platform=linux/amd64 \
          --opt "build-arg:GOPROXY=${GOPROXY:-}" \
          --opt "build-arg:npm_config_registry=${npm_config_registry:-}" \
          --opt "build-arg:NPM_CONFIG_REGISTRY=${NPM_CONFIG_REGISTRY:-}" \
          --opt "build-arg:PIP_INDEX_URL=${PIP_INDEX_URL:-}" \
          --opt "build-arg:PIP_TRUSTED_HOST=${PIP_TRUSTED_HOST:-}" \
          --export-cache "type=registry,ref=${CACHE_REPO}:${name},mode=max,image-manifest=true" \
          --import-cache "type=registry,ref=${CACHE_REPO}:${name}" \
          ${tags}
      }

      build_image "mentatlab-orchestrator-go" "services/orchestrator-go"
      build_image "mentatlab-gateway-go" "services/gateway-go"
      build_image "mentatlab-frontend" "services/frontend"
      build_image "mentatlab-echoagent" "services/agents/echo"
      build_image "mentatlab-psyche-sim" "agents/psyche-sim"
      build_image "mentatlab-ctm-cogpack" "agents/ctm-cogpack"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

# ==============================================================================
# E2E TEST STAGE
# ==============================================================================

e2e-test:
  stage: e2e
  needs: [build-images]
  image: docker:24-cli
  services:
    - name: docker:24-dind
      alias: docker
      command: ["--tls=false"]
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
    ORCHESTRATOR_IMAGE: "${REGISTRY}/mentatlab-orchestrator-go:${CI_COMMIT_SHORT_SHA}"
    GATEWAY_IMAGE: "${REGISTRY}/mentatlab-gateway-go:${CI_COMMIT_SHORT_SHA}"
    FRONTEND_IMAGE: "${REGISTRY}/mentatlab-frontend:${CI_COMMIT_SHORT_SHA}"
  before_script:
    - apk add --no-cache docker-compose curl jq git
    # Clone repo (global GIT_STRATEGY is none)
    - |
      echo "Cloning via external host ${GITLAB_EXTERNAL_HOST}..."
      git init -q .
      git remote add origin "https://gitlab-ci-token:${CI_JOB_TOKEN}@${GITLAB_EXTERNAL_HOST}/${CI_PROJECT_PATH}.git"
      git fetch -q --depth 20 origin "${CI_COMMIT_SHA}"
      git checkout -q -f "${CI_COMMIT_SHA}"
    - |
      echo "Waiting for Docker daemon..."
      for i in $(seq 1 30); do
        if docker info >/dev/null 2>&1; then
          echo "Docker daemon ready"
          break
        fi
        echo "[$i/30] Docker not ready yet..."
        sleep 2
      done
    - docker info
  script:
    - |
      echo "=== Starting E2E Tests ==="

      # Create docker-compose override for CI
      cat > docker-compose.ci.yml << 'EOF'
      services:
        orchestrator:
          image: ${ORCHESTRATOR_IMAGE:-registry.harbor.lan/library/mentatlab-orchestrator-go:latest}
          build: !reset null
        gateway:
          image: ${GATEWAY_IMAGE:-registry.harbor.lan/library/mentatlab-gateway-go:latest}
          build: !reset null
        frontend:
          image: ${FRONTEND_IMAGE:-registry.harbor.lan/library/mentatlab-frontend:latest}
          build: !reset null
      EOF

      # Start services
      echo "Starting services..."
      docker-compose -f docker-compose.yml -f docker-compose.ci.yml up -d

      # Wait for services to be healthy
      echo "Waiting for services to be healthy..."
      MAX_RETRIES=60
      for i in $(seq 1 $MAX_RETRIES); do
        ORCH_HEALTH=$(curl -sf http://localhost:7070/healthz 2>/dev/null && echo "ok" || echo "fail")
        GW_HEALTH=$(curl -sf http://localhost:8080/healthz 2>/dev/null && echo "ok" || echo "fail")
        FE_HEALTH=$(curl -sf http://localhost:5173 2>/dev/null && echo "ok" || echo "fail")

        if [ "$ORCH_HEALTH" = "ok" ] && [ "$GW_HEALTH" = "ok" ] && [ "$FE_HEALTH" = "ok" ]; then
          echo "All services healthy!"
          break
        fi

        echo "[$i/$MAX_RETRIES] Waiting... (orch=$ORCH_HEALTH, gw=$GW_HEALTH, fe=$FE_HEALTH)"
        sleep 2
      done

      # Run E2E tests
      echo "=== Running E2E Tests ==="

      # Test 1: Health endpoints
      echo "Test 1: Health endpoints..."
      curl -sf http://localhost:7070/healthz || (echo "FAIL: Orchestrator health" && exit 1)
      curl -sf http://localhost:8080/healthz || (echo "FAIL: Gateway health" && exit 1)
      echo "PASS: Health endpoints"

      # Test 2: API endpoints are reachable
      echo "Test 2: API endpoints..."
      curl -sf http://localhost:7070/api/v1/runs || (echo "FAIL: Runs endpoint" && exit 1)
      curl -sf http://localhost:7070/api/v1/agents || (echo "FAIL: Agents endpoint" && exit 1)
      echo "PASS: API endpoints"

      # Test 3: Gateway proxies to orchestrator
      echo "Test 3: Gateway proxy..."
      curl -sf http://localhost:8080/api/v1/runs || (echo "FAIL: Gateway proxy" && exit 1)
      echo "PASS: Gateway proxy"

      # Test 4: Frontend loads
      echo "Test 4: Frontend..."
      curl -sf http://localhost:5173 | grep -qi "<!DOCTYPE html>" || (echo "FAIL: Frontend" && exit 1)
      echo "PASS: Frontend"

      echo "=== All E2E Tests Passed ==="
  after_script:
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml logs --tail=100 || true
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml down -v || true
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  allow_failure: true

# ==============================================================================
# DEPLOY STAGE
# ==============================================================================

deploy:
  stage: deploy
  image: alpine/k8s:1.31.0
  needs: [build-images]
  variables:
    NAMESPACE: mentatlab
  before_script:
    - apk add --no-cache git
    # Clone repo (global GIT_STRATEGY is none)
    - |
      echo "Cloning via external host ${GITLAB_EXTERNAL_HOST}..."
      git init -q .
      git remote add origin "https://gitlab-ci-token:${CI_JOB_TOKEN}@${GITLAB_EXTERNAL_HOST}/${CI_PROJECT_PATH}.git"
      git fetch -q --depth 20 origin "${CI_COMMIT_SHA}"
      git checkout -q -f "${CI_COMMIT_SHA}"
    - |
      mkdir -p ~/.kube
      echo "${KUBECONFIG_K3S}" > ~/.kube/config
      chmod 600 ~/.kube/config
    - kubectl version --client
    - kubectl cluster-info
  script:
    - |
      echo "=== Deploying MentatLab to ${NAMESPACE} ==="
      cd k8s

      # Update image tags using kustomize
      echo "Setting image tags to ${CI_COMMIT_SHORT_SHA}..."
      kustomize edit set image \
        "registry.harbor.lan/library/mentatlab-orchestrator-go=${REGISTRY}/mentatlab-orchestrator-go:${CI_COMMIT_SHORT_SHA}" \
        "registry.harbor.lan/library/mentatlab-gateway-go=${REGISTRY}/mentatlab-gateway-go:${CI_COMMIT_SHORT_SHA}" \
        "registry.harbor.lan/library/mentatlab-frontend=${REGISTRY}/mentatlab-frontend:${CI_COMMIT_SHORT_SHA}" \
        "registry.harbor.lan/library/mentatlab-echoagent=${REGISTRY}/mentatlab-echoagent:${CI_COMMIT_SHORT_SHA}"

      # Apply manifests using server-side apply
      echo "Applying manifests..."
      kustomize build . | kubectl apply --server-side --force-conflicts -f -

      # Wait for rollouts
      echo "Waiting for deployments to roll out..."
      kubectl rollout status deployment/orchestrator -n ${NAMESPACE} --timeout=3m
      kubectl rollout status deployment/gateway -n ${NAMESPACE} --timeout=3m
      kubectl rollout status deployment/frontend -n ${NAMESPACE} --timeout=3m

      echo "=== Deployment complete ==="
      kubectl get pods -n ${NAMESPACE}
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
      when: manual
